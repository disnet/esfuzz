// Generated by CoffeeScript 2.0.0-beta5
void function () {
  var BlockStatement, cache$, cache$1, DebuggerStatement, EmptyStatement, escodegen, expressions, ExpressionStatement, FunctionDeclaration, FunctionExpression, Identifier, IfStatement, listOf, listOfAtLeast, maybe, notReserved, Number_, oneOf, Program, randomElement, randomInt, render, RoundtripFailureError, statements, String_, SwitchCase, SwitchCaseDefault, SwitchStatement, terminalStatements, toplevelStatements, WithStatement;
  escodegen = require('escodegen');
  cache$ = require('./helpers');
  randomInt = cache$.randomInt;
  randomElement = cache$.randomElement;
  cache$1 = require('./combinators');
  listOf = cache$1.listOf;
  listOfAtLeast = cache$1.listOfAtLeast;
  oneOf = cache$1.oneOf;
  maybe = cache$1.maybe;
  notReserved = cache$1.notReserved;
  Program = function () {
    return {
      type: 'Program',
      body: listOfAtLeast(statements, 1)
    };
  };
  BlockStatement = function () {
    return {
      type: 'BlockStatement',
      body: listOf(statements)
    };
  };
  ExpressionStatement = function () {
    return {
      type: 'ExpressionStatement',
      expression: oneOf(expressions)
    };
  };
  EmptyStatement = function () {
    return { type: 'EmptyStatement' };
  };
  DebuggerStatement = function () {
    return { type: 'DebuggerStatement' };
  };
  IfStatement = function () {
    return {
      type: 'IfStatement',
      test: oneOf(expressions),
      consequent: oneOf(statements),
      alternate: maybe(function () {
        return oneOf(statements);
      })
    };
  };
  WithStatement = function () {
    return {
      type: 'WithStatement',
      object: oneOf(expressions),
      body: oneOf(statements)
    };
  };
  SwitchStatement = function () {
    return {
      type: 'SwitchStatement',
      discriminant: oneOf(expressions),
      cases: listOf([SwitchCase]).concat(oneOf([
        SwitchCaseDefault,
        function () {
          return [];
        }
      ])),
      lexical: false
    };
  };
  SwitchCase = function () {
    return {
      type: 'SwitchCase',
      test: oneOf(expressions),
      consequent: [oneOf(statements)].concat(listOf(statements))
    };
  };
  SwitchCaseDefault = function () {
    return {
      type: 'SwitchCase',
      test: null,
      consequent: [oneOf(statements)].concat(listOf(statements))
    };
  };
  FunctionDeclaration = function () {
    return {
      type: 'FunctionDeclaration',
      id: notReserved(Identifier),
      params: listOf([function () {
          return notReserved(Identifier);
        }], 10),
      defaults: [],
      rest: null,
      body: BlockStatement(),
      generator: false,
      expression: false
    };
  };
  FunctionExpression = function () {
    return {
      type: 'FunctionExpression',
      id: maybe(function () {
        return notReserved(Identifier);
      }),
      params: listOf([function () {
          return notReserved(Identifier);
        }], 10),
      defaults: [],
      rest: null,
      body: BlockStatement(),
      generator: false,
      expression: false
    };
  };
  Identifier = function () {
    var identifierPart, identifierStart;
    identifierStart = identifierPart = function () {
      return String.fromCharCode(97 + randomInt(25));
    };
    return {
      type: 'Identifier',
      name: [identifierStart()].concat([].slice.call(function (accum$) {
        while (Math.random() < .8) {
          accum$.push(identifierPart());
        }
        return accum$;
      }.call(this, []))).join('')
    };
  };
  Number_ = function () {
    return oneOf([
      function () {
        return {
          type: 'Literal',
          value: 0
        };
      },
      function () {
        var int;
        int = randomInt(Math.pow(2, 53) - 1);
        return {
          type: 'Literal',
          value: int,
          raw: function () {
            switch (randomInt(10)) {
            case 0:
              return '' + randomElement([
                '0',
                '00',
                '000',
                '0000'
              ]) + int.toString(8);
            case 1:
              return '0' + randomElement([
                'x',
                'X'
              ]) + int.toString(16);
            default:
              return int.toString();
            }
          }.call(this)
        };
      }
    ]);
  };
  String_ = function () {
    var chars;
    chars = function (accum$) {
      while (Math.random() < .95) {
        accum$.push(String.fromCharCode(32 + randomInt(94)));
      }
      return accum$;
    }.call(this, []);
    return {
      type: 'Literal',
      value: chars.join('')
    };
  };
  terminalStatements = [
    ExpressionStatement,
    EmptyStatement,
    DebuggerStatement
  ];
  toplevelStatements = [].slice.call(terminalStatements).concat([
    IfStatement,
    BlockStatement,
    WithStatement,
    SwitchStatement,
    FunctionDeclaration
  ]);
  statements = [].slice.call(toplevelStatements).concat();
  expressions = [
    Number_,
    String_,
    function () {
      return notReserved(Identifier);
    },
    FunctionExpression
  ];
  RoundtripFailureError = function (super$) {
    extends$(RoundtripFailureError, super$);
    RoundtripFailureError.prototype.name = 'RoundtripFailureError';
    function RoundtripFailureError(param$) {
      this.message = param$;
      Error.call(this);
      if ('function' === typeof Error.captureStackTrace)
        Error.captureStackTrace(this, RoundtripFailureError);
    }
    return RoundtripFailureError;
  }(Error);
  render = function (program) {
    return escodegen.generate(program, { format: escodegen.FORMAT_MINIFY });
  };
  exports.fuzz = function (parsers) {
    var err, program, programAST, roundTrippedProgram, roundTrippedPrograms, targetProgram;
    programAST = Program();
    program = escodegen.generate(programAST, {
      verbatim: 'raw',
      format: escodegen.FORMAT_MINIFY
    });
    try {
      roundTrippedPrograms = function (accum$) {
        var parser;
        for (var i$ = 0, length$ = parsers.length; i$ < length$; ++i$) {
          parser = parsers[i$];
          accum$.push(render(parser.parse(program)));
        }
        return accum$;
      }.call(this, []);
    } catch (e$) {
      err = e$;
      err.ast = programAST;
      err.js = program;
      throw err;
    }
    targetProgram = render(programAST);
    for (var i$ = 0, length$ = roundTrippedPrograms.length; i$ < length$; ++i$) {
      roundTrippedProgram = roundTrippedPrograms[i$];
      if (!(roundTrippedProgram !== targetProgram))
        continue;
      err = new RoundtripFailureError;
      err.ast = programAST;
      err.js = program;
      throw err;
    }
  };
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
  function extends$(child, parent) {
    for (var key in parent)
      if (isOwn$(parent, key))
        child[key] = parent[key];
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  }
}.call(this);
