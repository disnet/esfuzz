// Generated by CoffeeScript 2.0.0-beta5
void function () {
  var BlockStatement, DebuggerStatement, EmptyStatement, escodegen, expressions, ExpressionStatement, FunctionDeclaration, FunctionExpression, Identifier, IfStatement, listOf, listOfAtLeast, maybe, notReserved, Number_, oneOf, Program, randomElement, randomInt, render, RESERVED, RoundtripFailureError, statements, String_, SwitchCase, SwitchCaseDefault, SwitchStatement, take, terminalStatements, toplevelStatements, WithStatement;
  escodegen = require('escodegen');
  RESERVED = [
    'break',
    'case',
    'catch',
    'class',
    'const',
    'continue',
    'debugger',
    'default',
    'delete',
    'do',
    'else',
    'enum',
    'export',
    'extends',
    'finally',
    'for',
    'function',
    'if',
    'import',
    'in',
    'instanceof',
    'new',
    'return',
    'super',
    'switch',
    'this',
    'throw',
    'try',
    'typeof',
    'var',
    'void',
    'while',
    'with',
    'implements',
    'let',
    'private',
    'public',
    'yield',
    'interface',
    'package',
    'protected',
    'static',
    'class',
    'enum',
    'extends',
    'super',
    'const',
    'export',
    'import',
    'null',
    'true',
    'false'
  ];
  randomInt = function (max) {
    return Math.floor(Math.random() * (max + 1));
  };
  randomElement = function (list) {
    return list[randomInt(list.length - 1)];
  };
  render = function (program) {
    return escodegen.generate(program, { format: escodegen.FORMAT_MINIFY });
  };
  take = function (n, list) {
    return function (accum$) {
      var e, i;
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        e = list[i$];
        i = i$;
        if (!(i < n))
          continue;
        accum$.push(e);
      }
      return accum$;
    }.call(this, []);
  };
  listOf = function (possibleGenerators) {
    return function (accum$) {
      while (Math.random() < .4) {
        accum$.push(oneOf(possibleGenerators));
      }
      return accum$;
    }.call(this, []);
  };
  listOfAtLeast = function (possibleGenerators, min) {
    return function (accum$) {
      var _;
      for (var i$ = 0, length$ = function () {
            var accum$1;
            var accum$1;
            accum$1 = [];
            for (var i$1 = 1; 1 <= min ? i$1 <= min : i$1 >= min; 1 <= min ? ++i$1 : --i$1)
              accum$1.push(i$1);
            return accum$1;
          }.apply(this, arguments).length; i$ < length$; ++i$) {
        _ = function () {
          var accum$1;
          var accum$1;
          accum$1 = [];
          for (var i$1 = 1; 1 <= min ? i$1 <= min : i$1 >= min; 1 <= min ? ++i$1 : --i$1)
            accum$1.push(i$1);
          return accum$1;
        }.apply(this, arguments)[i$];
        accum$.push(oneOf(possibleGenerators));
      }
      return accum$;
    }.call(this, []).concat(listOf(possibleGenerators));
  };
  oneOf = function (possibleGenerators) {
    return randomElement(possibleGenerators)();
  };
  maybe = function (generator) {
    if (randomElement([
        true,
        false
      ])) {
      return generator();
    } else {
      return null;
    }
  };
  notReserved = function (generator) {
    var id;
    id = generator();
    id.name = in$(id.name, RESERVED) ? '' + id.name + '_' : id.name;
    return id;
  };
  Program = function () {
    return {
      type: 'Program',
      body: listOfAtLeast(statements, 1)
    };
  };
  BlockStatement = function () {
    return {
      type: 'BlockStatement',
      body: listOf(statements)
    };
  };
  ExpressionStatement = function () {
    return {
      type: 'ExpressionStatement',
      expression: oneOf(expressions)
    };
  };
  EmptyStatement = function () {
    return { type: 'EmptyStatement' };
  };
  DebuggerStatement = function () {
    return { type: 'DebuggerStatement' };
  };
  IfStatement = function () {
    return {
      type: 'IfStatement',
      test: oneOf(expressions),
      consequent: oneOf(statements),
      alternate: maybe(function () {
        return oneOf(statements);
      })
    };
  };
  WithStatement = function () {
    return {
      type: 'WithStatement',
      object: oneOf(expressions),
      body: oneOf(statements)
    };
  };
  SwitchStatement = function () {
    return {
      type: 'SwitchStatement',
      discriminant: oneOf(expressions),
      cases: listOf([SwitchCase]).concat(oneOf([
        SwitchCaseDefault,
        function () {
          return [];
        }
      ])),
      lexical: false
    };
  };
  SwitchCase = function () {
    return {
      type: 'SwitchCase',
      test: oneOf(expressions),
      consequent: [oneOf(statements)].concat(listOf(statements))
    };
  };
  SwitchCaseDefault = function () {
    return {
      type: 'SwitchCase',
      test: null,
      consequent: [oneOf(statements)].concat(listOf(statements))
    };
  };
  FunctionDeclaration = function () {
    return {
      type: 'FunctionDeclaration',
      id: notReserved(Identifier),
      params: listOf([function () {
          return notReserved(Identifier);
        }], 10),
      defaults: [],
      rest: null,
      body: BlockStatement(),
      generator: false,
      expression: false
    };
  };
  FunctionExpression = function () {
    return {
      type: 'FunctionExpression',
      id: maybe(function () {
        return notReserved(Identifier);
      }),
      params: listOf([function () {
          return notReserved(Identifier);
        }], 10),
      defaults: [],
      rest: null,
      body: BlockStatement(),
      generator: false,
      expression: false
    };
  };
  Identifier = function () {
    var identifierPart, identifierStart;
    identifierStart = identifierPart = function () {
      return String.fromCharCode(97 + randomInt(25));
    };
    return {
      type: 'Identifier',
      name: [identifierStart()].concat([].slice.call(function (accum$) {
        while (Math.random() < .8) {
          accum$.push(identifierPart());
        }
        return accum$;
      }.call(this, []))).join('')
    };
  };
  Number_ = function () {
    return oneOf([
      function () {
        return {
          type: 'Literal',
          value: 0
        };
      },
      function () {
        var int;
        int = randomInt(Math.pow(2, 53) - 1);
        return {
          type: 'Literal',
          value: int,
          raw: function () {
            switch (randomInt(10)) {
            case 0:
              return '' + randomElement([
                '0',
                '00',
                '000',
                '0000'
              ]) + int.toString(8);
            case 1:
              return '0' + randomElement([
                'x',
                'X'
              ]) + int.toString(16);
            default:
              return int.toString();
            }
          }.call(this)
        };
      }
    ]);
  };
  String_ = function () {
    var chars;
    chars = function (accum$) {
      while (Math.random() < .95) {
        accum$.push(String.fromCharCode(32 + randomInt(94)));
      }
      return accum$;
    }.call(this, []);
    return {
      type: 'Literal',
      value: chars.join('')
    };
  };
  terminalStatements = [
    ExpressionStatement,
    EmptyStatement,
    DebuggerStatement
  ];
  toplevelStatements = [].slice.call(terminalStatements).concat([
    IfStatement,
    BlockStatement,
    WithStatement,
    SwitchStatement,
    FunctionDeclaration
  ]);
  statements = [].slice.call(toplevelStatements).concat();
  expressions = [
    Number_,
    String_,
    function () {
      return notReserved(Identifier);
    },
    FunctionExpression
  ];
  RoundtripFailureError = function (super$) {
    extends$(RoundtripFailureError, super$);
    RoundtripFailureError.prototype.name = 'RoundtripFailureError';
    function RoundtripFailureError(param$) {
      this.message = param$;
      Error.call(this);
      if ('function' === typeof Error.captureStackTrace)
        Error.captureStackTrace(this, RoundtripFailureError);
    }
    return RoundtripFailureError;
  }(Error);
  exports.fuzz = function (parsers) {
    var err, program, programAST, roundTrippedProgram, roundTrippedPrograms, targetProgram;
    programAST = Program();
    program = escodegen.generate(programAST, {
      verbatim: 'raw',
      format: escodegen.FORMAT_MINIFY
    });
    try {
      roundTrippedPrograms = function (accum$) {
        var parser;
        for (var i$ = 0, length$ = parsers.length; i$ < length$; ++i$) {
          parser = parsers[i$];
          accum$.push(render(parser.parse(program)));
        }
        return accum$;
      }.call(this, []);
    } catch (e$) {
      err = e$;
      err.ast = programAST;
      err.js = program;
      throw err;
    }
    targetProgram = render(programAST);
    for (var i$ = 0, length$ = roundTrippedPrograms.length; i$ < length$; ++i$) {
      roundTrippedProgram = roundTrippedPrograms[i$];
      if (!(roundTrippedProgram !== targetProgram))
        continue;
      err = new RoundtripFailureError;
      err.ast = programAST;
      err.js = program;
      throw err;
    }
  };
  function in$(member, list) {
    for (var i = 0, length = list.length; i < length; ++i)
      if (i in list && list[i] === member)
        return true;
    return false;
  }
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
  function extends$(child, parent) {
    for (var key in parent)
      if (isOwn$(parent, key))
        child[key] = parent[key];
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  }
}.call(this);
